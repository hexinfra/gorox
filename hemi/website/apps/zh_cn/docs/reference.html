<style type="text/css">
article {
	font-family: sans-serif;
}

article h1 {
	text-align: center;
	background: #d0e0f0;
}

article>ol {
	padding-left: 30px;
	list-style-type: none;
}

article h3 {
	margin: 12px 0px;
	padding:5px;
	color:#fff;
	background:#678;
}

article h4{
	color:#fff;
	background:#cba;
}

article h1,
article h2,
article h3,
article h4,
article h5,
article h6 {
	padding: 5px;
}

article p {
	padding: 5px;
	background: #ffffff;
	margin-right: 10px;
}

article code {
	display: block;
	padding: 10px;
	white-space: pre-line;
	line-height: 22px;
	background-color: #f5f5f5;
	border: 1px solid #ccc;
	border-radius: 4px;
	margin-right: 20px;
}

article code.pre {
	white-space: pre;
	-moz-tab-size: 2;
	-o-tab-size: 2;
	-webkit-tab-size: 2;
	tab-size: 2;
}


article ul {}

article li {
	padding: 2px;
}

article dt {
	font-weight: bold;
	font-style: italic;
}

article a {
	text-decoration: none;
}

article table {
	border-collapse: collapse;
}

article th,
article td {
	border: 1px solid #000;
}

article table.none tr td {
	border-collapse: collapse;
	border: none;
	height: 22px
}
</style>

<article>
	<h2>参考手册</h2>
	<p>本文列出 Gorox 内各组件的详尽参考。</p>

	<h3>目录</h3>
	<ol>
		<li><a href="#stage">stage</a></li>
		<li><a href="#stage-clock">stage &gt; clock</a></li>
		<li><a href="#stage-fcache">stage &gt; fcache</a></li>
		<li><a href="#stage-resolver">stage &gt; resolver</a></li>
		<li><a href="#stage-http1Outgate">stage &gt; http1Outgate</a></li>
		<li><a href="#stage-http2Outgate">stage &gt; http2Outgate</a></li>
		<li><a href="#stage-http3Outgate">stage &gt; http3Outgate</a></li>
		<li><a href="#stage-quicOutgate">stage &gt; quicOutgate</a></li>
		<li><a href="#stage-tcpsOutgate">stage &gt; tcpsOutgate</a></li>
		<li><a href="#stage-udpsOutgate">stage &gt; udpsOutgate</a></li>
		<li><a href="#stage-demoRunner">stage &gt; demoRunner</a></li>
		<li><a href="#stage-http1Backend">stage &gt; http1Backend</a></li>
		<li><a href="#stage-http2Backend">stage &gt; http2Backend</a></li>
		<li><a href="#stage-http3Backend">stage &gt; http3Backend</a></li>
		<li><a href="#stage-quicBackend">stage &gt; quicBackend</a></li>
		<li><a href="#stage-tcpsBackend">stage &gt; tcpsBackend</a></li>
		<li><a href="#stage-udpsBackend">stage &gt; udpsBackend</a></li>
		<li><a href="#stage-unixBackend">stage &gt; unixBackend</a></li>
		<li>stage &gt; quicRouter</li>
		<li>stage &gt; quicRouter &gt; case</li>
		<li>stage &gt; quicRouter &gt; [case &gt;] quicProxy</li>
		<li>stage &gt; tcpsRouter</li>
		<li>stage &gt; tcpsRouter &gt; case</li>
		<li>stage &gt; tcpsRouter &gt; [case &gt;] echoDealer</li>
		<li>stage &gt; tcpsRouter &gt; [case &gt;] helloDealer</li>
		<li>stage &gt; tcpsRouter &gt; [case &gt;] tcpsProxy</li>
		<li>stage &gt; tcpsRouter &gt; [case &gt;] mysqlViewer</li>
		<li>stage &gt; tcpsRouter &gt; [case &gt;] redisViewer</li>
		<li>stage &gt; udpsRouter</li>
		<li>stage &gt; udpsRouter &gt; case</li>
		<li>stage &gt; udpsRouter &gt; [case &gt;] dnsDealer</li>
		<li>stage &gt; udpsRouter &gt; [case &gt;] udpsProxy</li>
		<li>stage &gt; localStater</li>
		<li>stage &gt; redisStater</li>
		<li><a href="#stage-localCacher">stage &gt; localCacher</a></li>
		<li><a href="#stage-redisCacher">stage &gt; redisCacher</a></li>
		<li><a href="#stage-app">stage &gt; app</a></li>
		<li><a href="#stage-app-rule">stage &gt; app &gt; rule</a></li>
		<li><a href="#stage-app-accessChecker">stage &gt; app &gt; [rule &gt;] accessChecker</a></li>
		<li><a href="#stage-app-hostnameChecker">stage &gt; app &gt; [rule &gt;] hostnameChecker</a></li>
		<li><a href="#stage-app-httpsChecker">stage &gt; app &gt; [rule &gt;] httpsChecker</a></li>
		<li> <a href="#stage-app-limitChecker">stage &gt; app &gt; [rule &gt;] limitChecker</a></li>
		<li> <a href="#stage-app-refererChecker">stage &gt; app &gt; [rule &gt;] refererChecker</a></li>
		<li> <a href="#stage-app-rewriter">stage &gt; app &gt; [rule &gt;] rewriter</a></li>
		<li> <a href="#stage-app-ajpProxy">stage &gt; app &gt; [rule &gt;] ajpProxy</a></li>
		<li> <a href="#stage-app-favicon">stage &gt; app &gt; [rule &gt;] favicon</a></li>
		<li> <a href="#stage-app-fcgiProxy">stage &gt; app &gt; [rule &gt;] fcgiProxy</a></li>
		<li> <a href="#stage-app-http1Proxy">stage &gt; app &gt; [rule &gt;] http1Proxy</a></li>
		<li> <a href="#stage-app-http2Proxy">stage &gt; app &gt; [rule &gt;] http2Proxy</a></li>
		<li> <a href="#stage-app-http3Proxy">stage &gt; app &gt; [rule &gt;] http3Proxy</a></li>
		<li> <a href="#stage-app-sitex">stage &gt; app &gt; [rule &gt;] sitex</a></li>
		<li> <a href="#stage-app-static">stage &gt; app &gt; [rule &gt;] static</a></li>
		<li> <a href="#stage-app-uwsgiProxy">stage &gt; app &gt; [rule &gt;] uwsgiProxy</a></li>
		<li> <a href="#stage-app-webdavHandlet">stage &gt; app &gt; [rule &gt;] webdavHandlet</a></li>
		<li> <a href="#stage-app-gzipReviser">stage &gt; app &gt; [rule &gt;] gzipReviser</a></li>
		<li> <a href="#stage-app-headReviser">stage &gt; app &gt; [rule &gt;] headReviser</a></li>
		<li> <a href="#stage-app-replaceReviser">stage &gt; app &gt; [rule &gt;] replaceReviser</a></li>
		<li> <a href="#stage-app-ssiReviser">stage &gt; app &gt; [rule &gt;] ssiReviser</a></li>
		<li> <a href="#stage-app-wrapReviser">stage &gt; app &gt; [rule &gt;] wrapReviser</a></li>
		<li> <a href="#stage-app-helloSocklet">stage &gt; app &gt; [rule &gt;] helloSocklet</a></li>
		<li> <a href="#stage-app-sock1Proxy">stage &gt; app &gt; [rule &gt;] sock1Proxy</a></li>
		<li> <a href="#stage-app-sock2Proxy">stage &gt; app &gt; [rule &gt;] sock2Proxy</a></li>
		<li> <a href="#stage-app-sock3Proxy">stage &gt; app &gt; [rule &gt;] sock3Proxy</a></li>
		<li><a href="#stage-svc">stage &gt; svc</a></li>
		<li><a href="#stage-echoServer">stage &gt; echoServer</a></li>
		<li><a href="#stage-http3Server">stage &gt; http3Server</a></li>
		<li><a href="#stage-httpxServer">stage &gt; httpxServer</a></li>
		<li><a href="#stage-socksServer">stage &gt; socksServer</a></li>
		<li><a href="#stage-cleanCronjob">stage &gt; cleanCronjob</a></li>
		<li><a href="#stage-statCronjob">stage &gt; statCronjob</a></li>
	</ol>

	<h3>组件</h3>
	<ol style="margin-top:10px">
		<li id="stage">
			<h4>stage</h4>
			<p>stage 是 gorox 工作进程的运行阶段，其余的配置和组件都必须在 stage 内部。</p>
			<code>语法: stage { ... }
				默认值: 无
				是否必须: 必须，且唯一
			</code>
			<p>例子</p>
			<code class="pre">stage {
	app "example" {
		.hostnames = ("*.example.com")
		.webRoot = %baseDir + "/apps/example/root"
		static {}
	}

	httpxServer "main" {
		.forApps = ("example")
		.address = ":5080"
	}
}</code>

			<p>stage 配置定义的数据类型。</p>
			<code class="pre">Booleans:     true, false
Strings:     "", "foo", "abc`def", `abc"def`
Integers:    0, 314, 2222222222
Sizes:       1K, 2M, 3G, 4T
Durations:   1s, 2m, 3h, 4d
Lists:       (), ("a", "b"), ("c", 2, [])
Dicts:       [], ["a" : 1, "b" : ("two")]
</code>
		</li>

		<li>
			<p>stage 中常量，可以用在 stage 配置的任何位置。</p>
			<p>gorox 启动之后会定义如下常量，并且在整个运行阶段都不会再次修改。</p>
			<ul>
				<li>
					<code class="pre">%baseDir : gorox 可执行文件的当前目录

%logsDir : 启动 gorox 时候 参数 -logs 指定的的目录，
	 如果指定的是绝对目录，则采用这个目录。
	 如果指定的是相对目录，则 %baseDir 加上这个相对目录。
	 如果未指定目录，则 %baseDir 加上 logs，作为日志目录。

%tempDir : 启动 gorox 时候 参数 -temps 指定的的目录，
	 如果指定的是绝对目录，则采用这个目录。
	 如果指定的是相对目录，则 %baseDir 加上这个相对目录。
	 如果未指定目录，则 %baseDir 加上 temp，作为临时文件的目录。

%varsDir : 启动 gorox 时候 参数 -vars 指定的的目录，
	 如果指定的是绝对目录，则采用这个目录。
	 如果指定的是相对目录，则 %baseDir 加上这个相对目录。
	 如果未指定目录，则 %baseDir 加上 vars，作为vars目录。</code>
				</li>
			</ul>
		</li>

		<li>
			<p>stage 属性列表。</p>
			<code class="pre">stage {
	.cpuFile = %tempDir + "/cpu.prof"
	.hepFile = %tempDir + "/hep.prof"
	.thrFile = %tempDir + "/thr.prof"
	.grtFile = %tempDir + "/grt.prof"
	.blkFile = %tempDir + "/blk.prof"
}</code>
			<ul>
				<li>
					<p>.cpuFile: 采集 gorox 5s 的 CPU profile，只保留本次数据，此前已经存在的数据会清空。 采集命令: ./gorox cpu。
					</p>
					<code>语法：.cpuFile = "filename"
						默认值：%tempDir + "/cpu.prof"
					</code>

					<p>.hepFile: 采集 gorox 5s 的 heap profile，只保留本次数据，此前已经存在的数据会清空。 采集命令: ./gorox heap。</p>
					<code>语法：.hepFile = "filename"
						默认值：%tempDir + "/hep.prof"
					</code>

					<p>.thrFile: 采集 gorox 5s 的新创建的系统线程的堆栈数据，只保留本次数据，此前已经存在的数据会清空。 采集命令: ./gorox thread。</p>
					<code>语法：.thrFile = "filename"
						默认值：%tempDir + "/thr.prof"
					</code>


					<p>.grtFile: 采集 gorox 进程内所有当前 goroutine 的堆栈跟踪数据，只保留本次数据，此前已经存在的数据会清空。 采集命令: ./gorox goroutine。</p>
					<code>语法：.grtFile = "filename"
						默认值：%tempDir + "/grt.prof"
					</code>

					<p>.blkFile: 采集 gorox 5s 内导致阻塞同步原语的堆栈数据，只保留本次数据，此前已经存在的数据会清空。 采集命令: ./gorox block。</p>
					<code>语法：.blkFile = "filename"
						默认值：%tempDir + "/blk.prof"
					</code>
				</li>
			</ul>
		</li>

		<li id="stage-clock">
			<h4>stage &gt; clock</h4>
			<p>clock: gorox 获取时间并且缓存时间，每隔100ms更新一次，目前不可配置。用于http header中的date、expires、last-modified等。</p>
		</li>
		<li id="stage-fcache">
			<h4>stage &gt; fcache</h4>
			<p>fcache: 将静态文件缓存在内存中，用于加快访问速度，减少磁盘IO。</p>
			<code class="pre">stage { 
	fcache {
		.smallFileSize = 65535
		.maxSmallFiles = 1000
		.maxLargeFiles = 500
		.cacheTimeout = 1s
	}
}			</code>
			<ul>
				<li>
					<p>.smallFileSize 小于等于这个值的文件，将会把文件数据缓存在内存，大于这个值将会缓存文件对象。</p>
					<code>语法：.smallFileSize = Sizes
					默认值：64K
					取值范围：(0, 512M]
					</code>
				</li>
				<li>
					<p>.maxSmallFiles 最多可以缓存的小文件数量。</p>
					<code>语法：.smallFileSize = Integers
						默认值：1000
						取值范围：(0, maxInt32)
						</code>
				</li>
				<li>
					<p>.maxLargeFiles 最大缓存的大文件对象数量。</p>
					<code>语法：.maxLargeFiles = Integers
						默认值：500
						取值范围：(0, maxInt32)
					</code>
				</li>
				<li>
					<p>.cacheTimeout 缓存时长。</p>
					<code>语法：.cacheTimeout = Durations
						默认值：1s
						取值范围：(0s, +)
					</code>
				</li>
			</ul>
		</li>
		<li id="stage-resolver">
			<h4>stage &gt; resolver</h4>
			<p>resolver: 用于DNS解析ip4、ip6等。</p>
		</li>
		<li id="stage-http1Outgate">
			<h4>stage &gt; http1Outgate</h4>
			<p>http1.1 正向代理，通过 gorox 转发 http 请求。在整个 stage 里面只能配置一个 http1Outgate。<br />当 http1Proxy 设置 .proxyMode =
				"forward"，gorox 自动使用 http1Outgate 相关配置作为 http client 的配置。</p>
			<ul>
				<li>
					<p>例子</p>
					<code class="pre">stage {
	http1Outgate {
		.tlsMode = false
		.dialTimeout = 10s
		.writeTimeout = 30s
		.readTimeout = 30s
		.aliveTimeout = 4s
		.maxStreamsPerConn = 1000
		.saveContentFilesDir = %tempDir + "/web/outgates/http1Outgate"
		.maxContentSize = 1T
		.sendTimeout = 60s
		.recvTimeout = 60s
	}

	app "proxy" {
		.hostnames = ("*")
		rule { 
			http1Proxy {
				.proxyMode = "forward"
			}
		}
	}

	httpxServer "main" {
		.forApps = ("proxy")
		.address = ":3080"
	}
}

// 使用代理访问。
curl -x "http://127.0.0.1:3080" "http://www.gorox.io"
</code>
				</li>
				<li>
					<p>.tlsMode 作为 http client 对于请求 https 服务时是否验证服务器的证书链和主机名。</p>
					<code>语法：.tlsMode = bool
						默认值：false
						取值范围： false | true
					</code>
				</li>
				<li>
					<p>.dialTimeout tcp 连接超时时间，包含 DNS 解析的时间。</p>
					<code>语法：.dialTimeout = Durations
						默认值：10s
						取值范围： (1s, 10m]
					</code>
				</li>
				<li>
					<p>.writeTimeout 本次写数据超时时间，超过时间则连接关闭。</p>
					<code>语法：.writeTimeout = Durations
						默认值：30s
						取值范围： (1s, 10m]
					</code>
				</li>

				<li>
					<p>.readTimeout 本次读数据超时时间，超过时间则连接关闭。</p>
					<code>语法：.readTimeout = Durations
						默认值：30s
						取值范围： (1s, 10m]
					</code>
				</li>

				<li>
					<p>.aliveTimeout 连接存活时长，超过这个时间就从连接池剔除此连接。</p>
					<code>语法：.aliveTimeout = Durations
						默认值：4s
						取值范围：(1s, 10m]
					</code>
				</li>
				<li>
					<p>.maxStreamsPerConn 同一个连接最大使用次数，0 表示不受限制。</p>
					<code>语法：.maxStreamsPerConn = Integers
						默认值：1000
						取值范围：[0, maxInt32)
					</code>
				</li>
				<li>
					<p>.saveContentFilesDir 上传文件的临时目录，如果配置路径不存在，会自动创建，权限0755。</p>
					<code>语法：.saveContentFilesDir = "path"
						默认值：%tempDir + "/web/outgates/http1Outgate"
						取值范围：-
					</code>
				</li>
				<li>
					<p>.maxContentSize 整个 http 数据包最大限制。</p>
					<code>语法：.maxContentSize = Sizes
						默认值：1T
						取值范围： (0, maxInt64)
					</code>
				</li>
				<li>
					<p>.sendTimeout 发送整个 http 数据超时时间。</p>
					<code>语法：.sendTimeout = Durations
						默认值：60s
						取值范围： (0s, 10m]
					</code>
				</li>
				<li>
					<p>.recvTimeout 接收整个 http 数据超时时间。</p>
					<code>语法：.recvTimeout = Durations
						默认值：60s
						取值范围： (0s, 10m]
					</code>
				</li>
			</ul>
		</li>
		<li id="stage-http2Outgate">
			<h4>stage &gt; http2Outgate</h4>
			<p>http2 正向代理，通过 gorox 转发 http 请求。在整个 stage 里面只能配置一个 http2Outgate。<br />当 http2Proxy 设置 .proxyMode =
				"forward"，gorox 自动使用 http2Outgate 相关配置作为 http client 的配置。
			</p>
			<ul>
				<li>
					<code class="pre">http2Outgate {
	.tlsMode = false
	.dialTimeout = 10s
	.writeTimeout = 30s
	.readTimeout = 30s
	.aliveTimeout = 5s
	.maxStreamsPerConn = 1000
	.saveContentFilesDir = %tempDir + "/web/outgates/http2Outgate"
	.maxContentSize = 1T
	.sendTimeout = 60s
	.recvTimeout = 60s
}</code>
				</li>
				<li>
					<p>.tlsMode 作为 http client 对于请求 https 服务时是否验证服务器的证书链和主机名。</p>
					<code>语法：.tlsMode = bool
						默认值：false
						取值范围： false | true
					</code>
				</li>
				<li>
					<p>.dialTimeout tcp 连接超时时间，包含 DNS 解析的时间。</p>
					<code>语法：.dialTimeout = Durations
						默认值：10s
						取值范围： (1s, 10m]
					</code>
				</li>
				<li>
					<p>.writeTimeout 本次写数据超时时间，超过时间则连接关闭。</p>
					<code>语法：.writeTimeout = Durations
						默认值：30s
						取值范围： (1s, 10m]
					</code>
				</li>
				<li>
					<p>.readTimeout 本次读数据超时时间，超过时间则连接关闭。</p>
					<code>语法：.readTimeout = Durations
						默认值：30s
						取值范围： (1s, 10m]
					</code>
				</li>
				<li>
					<p>.aliveTimeout 连接存活时长，超过这个时间就从连接池剔除此连接。</p>
					<code>语法：.aliveTimeout = Durations
						默认值：4s
						取值范围：(1s, 10m]
					</code>
				</li>
				<li>
					<p>.maxStreamsPerConn 同一个连接最大使用次数，0 表示不受限制。</p>
					<code>语法：.maxStreamsPerConn = Integers
						默认值：1000
						取值范围：[0, maxInt32)
					</code>
				</li>
				<li>
					<p>.saveContentFilesDir 上传文件的临时目录，如果配置路径不存在，会自动创建，权限0755。</p>
					<code>语法：.saveContentFilesDir = "path"
						默认值：%tempDir + "/web/outgates/http2Outgate"
						取值范围：-
					</code>
				</li>
				<li>
					<p>.maxContentSize 整个 http 数据包最大限制。</p>
					<code>语法：.maxContentSize = Sizes
						默认值：1T
						取值范围： (0, maxInt64)
					</code>
				</li>
				<li>
					<p>.sendTimeout 发送整个 http 数据超时时间。</p>
					<code>语法：.sendTimeout = Durations
						默认值：60s
						取值范围： (0s, 10m]
					</code>
				</li>
				<li>
					<p>.recvTimeout 接收整个 http 数据超时时间。</p>
					<code>语法：.recvTimeout = Durations
						默认值：60s
						取值范围： (0s, 10m]
					</code>
				</li>
			</ul>
		</li>
		<li id="stage-http3Outgate">
			<h4>stage &gt; http3Outgate</h4>
			<ul>
				<li>TODO</li>
			</ul>
		</li>
		<li id="stage-quicOutgate">
			<h4>stage &gt; quicOutgate</h4>
			<ul>
				<li>TODO</li>
			</ul>
		</li>
		<li id="stage-tcpsOutgate">
			<h4>stage &gt; tcpsOutgate</h4>
			<ul>
				<li>TODO</li>
			</ul>
		</li>
		<li id="stage-udpsOutgate">
			<h4>stage &gt; udpsOutgate</h4>
			<ul>
				<li>TODO</li>
			</ul>
		</li>
		<li id="stage-demoRunner">
			<h4>stage &gt; demoRunner</h4>
			<ul>
				<li>TODO</li>
			</ul>
		</li>
		<li id="stage-http1Backend">
			<h4>stage &gt; http1Backend</h4>
			<p>例子</p>
			<code class="pre">stage {
	http1Backend "h1b" {
		.tlsMode = false
		.dialTimeout = 10s
		.writeTimeout = 30s
		.readTimeout = 30s
		.aliveTimeout = 4s
		.nodes = (
			["address": "127.0.0.1:3080", "weight": 9, "keepConns": 20],
			["address": "127.0.0.1:3080", "weight": 8, "keepConns": 30],
		)
		.maxStreamsPerConn = 1000
		.saveContentFilesDir = %tempDir + "/web/backends/h1b"
		.maxContentSize = 1T
		.sendTimeout = 60s
		.recvTimeout = 60s
		.balancer = "roundRobin"
	}

	app "proxy" {
		.hostnames = ("*")
		rule { // match all url
			http1Proxy {
				.toBackend = "h1b"
				.proxyMode = "reverse"
			}
		}
	}

	httpxServer "main" {
		.forApps = ("proxy")
		.address = ":3080"
	}
}
</code>
			<ul>
				<li>
					<p>.tlsMode 作为 http client 对于请求 https 服务时是否验证服务器的证书链和主机名。</p>
					<code>语法：.tlsMode = bool
						默认值：false
						取值范围： false | true
					</code>
				</li>
				<li>
					<p>.dialTimeout tcp 连接超时时间，包含 DNS 解析的时间。</p>
					<code>语法：.dialTimeout = Durations
						默认值：10s
						取值范围： (1s, 10m]
					</code>
				</li>
				<li>
					<p>.writeTimeout 本次写数据超时时间，超过时间则连接关闭。</p>
					<code>语法：.writeTimeout = Durations
						默认值：30s
						取值范围： (1s, 10m]
					</code>
				</li>
				<li>
					<p>.readTimeout 本次读数据超时时间，超过时间则连接关闭。</p>
					<code>语法：.readTimeout = Durations
						默认值：30s
						取值范围： (1s, 10m]
					</code>
				</li>
				<li>
					<p>.aliveTimeout 连接存活时长，超过这个时间就从连接池剔除此连接。</p>
					<code>语法：.aliveTimeout = Durations
						默认值：4s
						取值范围：(1s, 10m]
					</code>
				</li>
				<li>
					<p>.node 反向代理的服务列表。</p>
					<code>语法：.nodes = (
								["address": "127.0.0.1:3080", "weight": 9, "keepConns": 20],
								["address": "127.0.0.1:3080", "weight": 8, "keepConns": 30],
							)
					默认值：nil
					取值范围： -

					address: 服务地址，必选项且不能为空。
					weight: 权重，默认值 1。
					keepConns: 当前 address 最多创建长连接数量，默认值10。
					</code>
				</li>
				<li>
					<p>.maxStreamsPerConn 同一个连接最大使用次数，0表示不受限制。</p>
					<code>语法：.maxStreamsPerConn = Integers
						默认值：1000
						取值范围：[0, maxInt32)
					</code>
				</li>
				<li>
					<p>.saveContentFilesDir 上传文件的临时目录，如果配置路径不存在，会自动创建，权限0755。</p>
					<code>语法：.saveContentFilesDir = "path"
						默认值：%tempDir + "/web/outgates/http2Outgate"
						取值范围：-
					</code>
				</li>
				<li>
					<p>.maxContentSize 整个 http 数据包最大限制。</p>
					<code>语法：.maxContentSize = Sizes
						默认值：1T
						取值范围： (0, maxInt64)
					</code>
				</li>
				<li>
					<p>.sendTimeout 发送整个 http 数据超时时间。</p>
					<code>语法：.sendTimeout = Durations
						默认值：60s
						取值范围： (0s, 10m]
					</code>
				</li>
				<li>
					<p>.recvTimeout 接收整个 http 数据超时时间。</p>
					<code>语法：.recvTimeout = Durations
						默认值：60s
						取值范围： (0s, 10m]
					</code>
				</li>
				<li>
					<p>.balancer 选择反向代理的负载均衡算法。</p>
					<code>语法：.balancer = "roundRobin"
						默认值：60s
						取值范围： roundRobin | ipHash | random

						roundRobin: 将请求按顺序轮流地分配到服务上，它均衡地对待后端的每一台服务器。
						ipHash: 通过hash算法将请求的IP映射到后端服务上，好处是同一个请求只会落在同一台服务器上进行处理。
						random: 随机将请求分配到后端服务上。
					</code>
				</li>
			</ul>
		</li>
		<li id="stage-http2Backend">
			<h4>stage &gt; http2Backend</h4>
			<ul>
				<li>TODO</li>
			</ul>
		</li>
		<li id="stage-http3Backend">
			<h4>stage &gt; http3Backend</h4>
			<ul>
				<li>TODO</li>
			</ul>
		</li>
		<li id="stage-quicBackend">
			<h4>stage &gt; quicBackend</h4>
			<ul>
				<li>TODO</li>
			</ul>
		</li>
		<li id="stage-tcpsBackend">
			<h4>stage &gt; tcpsBackend</h4>
			<ul>
				<li>TODO</li>
			</ul>
		</li>
		<li id="stage-udpsBackend">
			<h4>stage &gt; udpsBackend</h4>
			<ul>
				<li>TODO</li>
			</ul>
		</li>

		<li id="stage-unixBackend">
			<h4>stage &gt; unixBackend</h4>
			<ul>
				<li>TODO</li>
			</ul>
		</li>

		<li id="stage-localCacher">
			<h4>stage &gt; localCacher</h4>
			<p>localCacher：本地文件 cache，根据 http 的 header 信息把远端的数据缓存在本地。</p>
			<ul>
				<li>
					<p>.cacheDir 缓存目录</p>
					<code>语法：.cacheDir = "path"
					默认值： %varsDir + "/cachers/cache_name"
					取值范围：-
				</code>
				</li>
			</ul>
		</li>

		<li id="stage-redisCacher">
			<h4>stage &gt; redisCacher</h4>
			<p>redisCacher：根据 http 的 header 信息把远端的数据缓存在 redis 中。</p>
			<ul>
				<li>
					<p>.node redis 的服务列表。</p>
					<code>语法：.nodes = (
								["address": "127.0.0.1:3080", "weight": 9, "keepConns": 20],
								["address": "127.0.0.1:3080", "weight": 8, "keepConns": 30],
							)
					默认值：nil
					取值范围： -

					address: 服务地址，必选项且不能为空。
					weight: 权重，默认值 1。
					keepConns: 当前 address 最多创建长连接数量，默认值10。
					</code>
				</li>
			</ul>
		</li>

		<li id="stage-app">
			<h4>stage &gt; app </h4>
			<p>app：应用服务器的配置说明。</p>
			<ul>
				<li>
					<code>语法：.app [name] {....}
					默认值：-
					取值范围：-
				</code>
					<p>例子</p>
					<code class="pre">stage {
	http1Backend "h1b" {
		.balancer = "roundRobin"
		.nodes = (
			["address": "127.0.0.1:3080", "weight": 1],
			["address": "127.0.0.1:3090", "weight": 1],
		)
	}

	app "proxy" {
		.hostnames = ("example.com" "*.example.com" "www.example*")
		.saveContentFilesDir = %tempDir + "/apps/name"
		.webRoot = %baseDir + "/apps/proxy/root"
		.accessLog = [
			"logFile": %logsDir + "/apps/zh_cn.log",
			"rotate" : "day",
			"format" : "%T",
		]
		.maxMemoryContentSize = 16M
		.maxUploadContentSize = 128M
		.settings = []
		.proxyOnly = false
		.withStater = ""
		.file404 = ""
		.tlsCertificate = ""
		.tlsPrivateKey = ""

		rule $path -f { // 如果是文件就使用static处理
			static {}
		}

		rule { // 文件以外的全部转发到 h1b 对应的服务上
			http1Proxy {
				.toBackend = "h1b"
			}
		}
	}

	httpxServer "main" {
		.forApps = ("proxy")
		.address = ":80"
	}
}</code>
				</li>
				<li>
					<p>.hostnames 当前 app 的 hostname 可以配置多个。</p>
					<code>语法： .hostnames = ("example.com", "*.example.com")
					默认值： -  //必须配置
					取值范围：-
				</code>
				</li>
				<li>
					<p>.saveContentFilesDir 上传文件的临时目录，如果配置路径不存在，会自动创建，权限0755。</p>
					<code>语法：.saveContentFilesDir = "path"
						默认值：%tempDir + "/apps/name"
						取值范围：-
				</code>
				</li>
				<li>
					<p>.webRoot web 资源的根路径，存放图片、代码等文件。</p>
					<code>语法： .webRoot = "path"
					默认值： -  // 必须配置
					取值范围：-
				</code>
				</li>
				<li>
					<p>.maxMemoryContentSize 一个请求可以加载到内存中的最大内容大小。</p>
					<code>语法： .maxMemoryContentSize = Sizes
					默认值： 16M
					取值范围：(0, 1G]
				</code>
				</li>
				<li>
					<p>.maxUploadContentSize 一个请求可以上传最大文件的上限。</p>
					<code>语法： .maxUploadContentSize = Sizes
					默认值：128M
					取值范围：(0, 1T]
				</code>
				</li>
				<li>
					<p>.settings 用户的自定义数据。</p>
					<code>语法： .settings = ["bar" : "foo", "bar2" : "foo2"]
						默认值： - 
						取值范围：-
				</code>
				</li>
				<li>
					<p>.proxyOnly 当前 app 仅仅用于代理使用？</p>
					<code>语法： .proxyOnly = false
					默认值： false
					取值范围：false | true
					</code>
				</li>
				<li>
					<p>.withStater 使用那个 stater。</p>
					<code>语法： .withStater = "Stater-name"
						默认值： -  
						取值范围：-
					</code>
				</li>

				<li>
					<p>.file404 当前app的404配置。</p>
					<code>语法： .file404 = "file path"
						默认值： -  
						取值范围：-
					</code>
				</li>

				<li>
					<p>.tlsCertificate SSL/TLS 证书路径，格式为 crt、pem、der 等。如果要开启 https 则必须配置。</p>
					<code>语法： .tlsCertificate = "file path"
						默认值： -  
						取值范围：-
					</code>
				</li>

				<li>
					<p>.tlsPrivateKey SSL/TLS 的私钥路径，格式为 key、pem、der 等。如果要开启 https 则必须配置。</p>
					<code>语法： .tlsPrivateKey = "file path"
						默认值： - 
						取值范围：-
					</code>
				</li>
			</ul>
		</li>

		<li id="stage-app-rule">
			<h4>stage &gt; app &gt; rule </h4>
			<p>rule：在请求中根据某些特定的 URL 对应的一系列配置项。如果配置多个，则按照从上到下的顺序匹配，一旦匹配成功就停止向下寻找。</p>
			<ul>
				<li>
					<p>rule 匹配规则。</p>
					<code>语法： rule &lt;name&gt; &lt;cond&gt; { .. }
						默认值： rule {}  匹配所有
						取值范围：-
					</code>

					<p>rule 属性说明。</p>
					<p>.logAccess 是否开启日志。</p>
					<code>语法：.logAccess = false
						默认值： false
						取值范围：true | false
					</code>

					<p>.returnCode 设置http返回码。</p>
					<code>语法：.returnCode = 200
						默认值： -
						取值范围：[100, 1000)
					</code>

					<p>.returnText 设置http内容。</p>
					<code>语法：.returnText = "xxxx"
						默认值： -
						取值范围：任意值
					</code>

					<p>.handlets 使用自定义的 handlets 进行处理。</p>
					<code>语法：.handlets = ("handlets_bar", "handlets_foo")
						默认值： -
						取值范围：任意值
					</code>

					<p>.socklets 使用自定义的 socklets 进行处理。</p>
					<code>语法：.socklets = ("socklets_bar", "socklets_foo")
						默认值： -
						取值范围：-
					</code>

					<p>.revisers 使用自定义的 revisers 进行处理。</p>
					<code>语法：.revisers = ("revisers_bar", "revisers_foo")
						默认值： -
						取值范围：-
					</code>

					</code>
					<p>rule 变量说明。</p>
					<code>
					<table class="none">
						<tr>
							<td width="120">$method</td>
							<td>HTTP的请求方法（GET、POST、HEAD等）。</td>
						</tr>
						<tr>
							<td>$scheme</td>
							<td>请求协议，如HTTP、HTTPS等。</td>
						</tr>
						<tr>
							<td>$authority</td>
							<td>域名和端口部分，如：www.example.com, www.example.org:8080。</td>
						</tr>
						<tr>
							<td>$hostname</td>
							<td>URL 中域名的部分，如：www.example.com。</td>
						</tr>
						<tr>
							<td>$colonPort</td>
							<td>带冒号的端口，如果 URL 没有端口则使用默认，HTTP 默认是:80, HTTPS 默认是:443。</td>
						</tr>
						<tr>
							<td>$path</td>
							<td>URL 中 path 的部分，如：/a/b/c。</td>
						</tr>
						<tr>
							<td>$encodedPath</td>
							<td>URL 中 path 的部分，如果 path 部分包含 urlencode，则保留。</td>
						</tr>
						<tr>
							<td>$queryString</td>
							<td>URL 中参数的部分，如：?a=1&b=2。</td>
						</tr>
						<tr>
							<td>$uri</td>
							<td>URL 中 path 和 queryString，如：/a/b/c?a=1&b=2。</td>
						</tr>
						<tr>
							<td>$contentType</td>
							<td>HTTP 的请求头里面 content-Type 的值。</td>
						</tr>
					</table>
		</code>
					<p>rule 条件 说明</p>
					<code class="pre">==	变量和给定值，是否完全匹配。
^=	变量和给定值，是否前缀匹配。
$=	变量和给定值，是否后缀匹配。
~=	变量和给定值，通过正则表达式进行匹配。
-f	判断变量是否是文件。
-d	判断变量是否是目录。
-e	判断文件或者目录是否存在。
!=	变量和给定值，是否不匹配。
!^	变量和给定值，是否前缀不匹配。
!$	变量和给定值，是否前缀不匹配。
!~	变量和给定值，通过正则表达式是否匹配失败。
!f	判断变量是否不是文件。
!d	判断变量是否不是目录。
!e	判断文件或者目录是否不存在。
	</code>

					<p>rule 例子</p>
					<code class="pre">tcpsBackend "fpm" {
	.balancer = "roundRobin"
	.nodes = (
		["address": "127.0.0.1:9000"],
	)
}

app "main" {
		
	rule $path == /phpstatus { // 全匹配
		fcgiProxy {
			.toBackend = "fpm"
		}
	}

	rule $path == "/favicon.ico" { // favicon.ico 不记录日志
		.logAccess = false
	}

	// 通过前缀匹配，划分子服务
	rule $path ^= "/user" { // 用户服务
		http1Proxy { 
			.toBackend = "user_center"
		}
	}

	rule $path ^= "/order" { // 订单服务
		http1Proxy {
			.toBackend = "order_server"
		}
	}

	rule $path $= (".doc", ".docx", ".pdf") { // 禁止对外访问
		.returnCode = 403
	}

	rule $path ^= ("/robots.txt", "/static/") { // 静态资源添加cache
		static {}
		headReviser {
			.addResponse = ["cache-control" : "max-age=86400"]
		}
	}

	rule $path ~= "\.php$" { // 后缀是 php 都转到 fpm 上。
		fcgiProxy {
			.toBackend = "fpm"
		}
	}

	rule $queryString ~= "version=4.11" { // 根据 query 判断版本
		.returnCode = 302
		headReviser {
			.addResponse = ["Location" : "/upgrade.html"]
		}
	}

	rule $path !-e { // 文件路径变更
		.returnCode = 302
		headReviser {
			.addResponse = ["Location" : "new_path" + $uri]
		}
	}

	rule $path -d { // 允许浏览目录
		static {
			.autoIndex = true
		}
	}
}</code>
				</li>
			</ul>
		</li>

		<li id="stage-app-accessChecker">
			<h4>stage &gt; app &gt; accessChecker </h4>
			<p> accessChecker 对 ip 做检测，可以设置白名单或者黑名单。其中白名单和黑名单不能有同样的配置。拒绝访问 ip 将会返回403。</p>
			<ul>
				<li>
					<p>.allow 设置白名单。</p>
					<code>语法 .allow = ("all")
						默认值： "all"
						取值范围：ip | cidr | "all"
					</code>
				</li>
				<li>
					<p>.deny 设置黑名单。</p>
					<code>语法 .deny = ()
						默认值： -
						取值范围：ip | cidr | "all"
					</code>
				</li>
				<li>
					<p>取值字段说明。</p>
					<code>ip: 一个单独合法 ip，ipv4 或 ipv6。
						cidr: 无类别域间路由，192.168.6.1/24、10.100.1.1/16
						all: 针对所有的 ip 生效。

						优先级: ip > cidr > all 
					</code>
				</li>
				<li>
					<p>例子</p>
					<code>accessChecker { // 只允许 本机ip、10.100.*.*、192.168.1.* 的ip访问。
					.allow = ("10.100.1.1/16", "127.0.0.1", "::1", "192.168.1.1/24")
					.deny = ("all")
					}
					
					accessChecker { // 192.168.1的 ip 段，只允许 192.168.1.1、192.168.1.2 访问。
					.allow = ("192.168.1.1", "192.168.1.2")
					.deny = ("192.168.1.1/24")
					}
					
					accessChecker { // 不允许 10.100 开头的 ip 段访问。
					.allow = ("all")
					.deny = ("10.100.1.1/16")
					}
					</code>
				</li>
			</ul>
		</li>

		<li id="stage-app-hostnameChecker">
			<h4>stage &gt; app &gt; hostnameChecker </h4>
			<p> hostnameChecker 对域名做检测。</p>
			<ul>
				<li>
					<p>.hostname 期望的域名。</p>
					<code>语法 .hostname = ""
						默认值： -
						取值范围：-
					</code>
				</li>
				<li>
					<p>.permanent 如果为 true，并且 URL 的 hostname 和配置的不一致，则跳转到配置的域名上。</p>
					<code>语法： .permanent = false
						默认值： false
						取值范围：false | true
					</code>
				</li>
			</ul>

		</li>

		<li id="stage-app-httpsChecker">
			<h4>stage &gt; app &gt; httpsChecker </h4>
			<p> httpsChecker 对请求是否是 https 做检测。如果开启检测并且.authority 不为空，则使用https跳转到authority上。</p>
			<ul>
				<li>
					<p>.permanent 如果为 true，并且 URL 的不是 https，则使用 https 跳转到.authority 上。</p>
					<code>语法： .permanent = false
						默认值： false
						取值范围：false | true
					</code>
				</li>
				<li>
					<p>.authority 使用当前配置的.authority 替换请求 url 中的 authority，然后发起 301 跳转。</p>
					<code>语法 .authority = hostname:port
						默认值： -
						取值范围：-
					</code>
				</li>
			</ul>
		</li>
		<li id="stage-app-limitChecker">
			<h4>stage &gt; app &gt; limitChecker </h4>
		</li>

		<li id="stage-app-refererChecker">
			<h4>stage &gt; app &gt; refererChecker </h4>
			<p> refererChecker 验证 http 请求中的 referer 是否符合要求。</p>
			<ul>
				<li>
					<p>.serverNames 配置域名和path部分。</p>
					<code>语法： .serverNames = ("*.gorox.com", "gorox.*", "h5.exp.cn/app","bar.*/app", "~\.google\.")
						默认值： nil
						取值说明：
						1、全匹配： 如 www.gorox.io、www.gorox.io/app/ 等。
						2、部分匹配：可以通过 '*' 通配符，如 *.gorox.io、gorox.*、www.gorox.*/app，但是不允许 *.gorox.*。
						3、正则匹配：必须是以"~"开头，表达式将与"http://"或"https://"之后开始的文本匹配。 如 "~.*"、"~gorox.io$"、"~gorox.io/app"、"~\.gorox\." 。
					</code>
				</li>
				<li>
					<p>.none 是否允许 'Referer' 不存在。</p>
					<code>语法 .none = false
						默认值： false
						取值范围：false | true
					</code>
				</li>
				<li>
					<p>.blocked 存在 'Referer' 就算通过。因为请求头中可能存在其值已被防火墙或代理服务器删除。这种值是不以 "http://"或 "https://"开头的字符串。</p>
					<code>语法 .blocked = false
						默认值： false
						取值范围：false | true
					</code>
				</li>
				<li>
					<p>例子</p>
					<code>refererChecker { // referer 存在就算通过。
							.blocked = true
						}

						refererChecker { // referer 可以不存在，但是如果存在就必须符合 .serverNames 的配置规则。
							.none = false
							.serverNames = ("*.gorox.com"）
						}
					</code>
				</li>

			</ul>

		</li>

		<li id="stage-app-rewriter">
			<h4>stage &gt; app &gt; rewriter </h4>
		</li>

		<li id="stage-app-favicon">
			<h4>stage &gt; app &gt; favicon </h4>
		</li>

		<li id="stage-app-ajpProxy">
			<h4>stage &gt; app &gt; ajpProxy </h4>
		</li>

		<li id="stage-app-uwsgiProxy">
			<h4>stage &gt; app &gt; uwsgiProxy </h4>
		</li>

		<li id="stage-app-fcgiProxy">
			<h4>stage &gt; app &gt; fcgiProxy </h4>
			<p>fcgiProxy 用于 fastcgi 协议的后端代理，比如代理 php-fpm。 </p>
			<code class="pre">语法：fcgiProxy [name] { ... }

// 例子
stage {
	tcpsBackend "php-fpm" {
		.balancer = "roundRobin"
		.nodes = (
			["address": "127.0.0.1:9000"],
			["address": "127.0.0.1:9001"],
		)
	}

	app "main" {
		.webRoot = %baseDir + "/apps/diogin/root"

		fcgiProxy "fpm" {
			.toBackend = "php-fpm"
		}

		rule $hostname == "localhost" {
			.handlets = ("fpm")
		}

		rule $path ~= "\.php$" {
			fcgiProxy {
				.toBackend = "php-fpm"
			}
		}
	}
}
</code>
			<ul>
				<li>
					<p>.saveContentFilesDir 保存文件的路径，如果配置路径不存在，会自动创建，权限0755。</p>
					<code>语法： .saveContentFilesDir = "path"  
						默认值：%tempDir + "/fcgi/fpm"
					</code>
				</li>

				<li>
					<p>.toBackend 配置反向代理的名称。</p>
					<code>语法：  .toBackend = "proxy-name"
						默认值：- ; 必填项
					</code>
				</li>

				<li>
					<p>.withCacher 选择使用 cache 的名字。</p>
					<code>语法： .withCacher = "cacher-name"
						默认值： -  
						取值范围：-
					</code>
				</li>
				<li>
					<p>.scriptFilename 执行脚本的名称，使用绝对路径，一旦设置无论什么路径将总是执行这个脚本，可以作为 PHP 框架的入口文件。如果为空则使用请求 URL 中的脚本名称。</p>
					<code>语法：.scriptFilename = "/data/www/xxx/index.php"
						默认值： ""
						取值范围：-
					</code>
				</li>
				<li>
					<p>.indexFile 如当前请求的是路径，则执行此路径下的 index.php 文件。</p>
					<code>语法：.indexFile = "index.php"
						默认值： "index.php"
						取值范围：-
					</code>
				</li>
				<li>
					<p>.keepConn gorox 和 fastcgi 服务之间是否保存长连接？</p>
					<code>语法：.keepConn = false
						默认值： false
						取值范围：false | true
					</code>
				</li>
				<li>
					<p>.bufferClientContent 是否开启客户端缓冲区？</p>
					<code>语法：.bufferClientContent = true
						默认值： true
						取值范围：false | true
					</code>
				</li>
				<li>
					<p>.bufferServerContent 是否开启服务端缓冲区？</p>
					<code>语法：.bufferServerContent = true
						默认值： true
						取值范围：false | true
					</code>
				</li>
				<li>
					<p>.sendTimeout 发送整个 cgi 数据包超时时间。0 意味着不设置超时时间。</p>
					<code>语法：.sendTimeout = 60s
						默认值：60s
						取值范围： [0s, 10m]
					</code>
				</li>
				<li>
					<p>.recvTimeout 读取整个 cgi 数据包超时时间。0意味着不设置超时时间。</p>
					<code>语法：.recvTimeout = Durations
						默认值：60s
						取值范围： [0s, 10m]
					</code>
				</li>
				<li>
					<p>.maxContentSize cgi数据包最大限制</p>
					<code>语法：.maxContentSize = 128M
						默认值：1T
						取值范围： [0, +]
					</code>
				</li>
				<li>
					<p>.preferUnderscore 当 header 同时存在"foo-bar"与"foo_bar", 优先选择"foo_bar"</p>
					<code>语法：.preferUnderscore = false
						默认值：false
						取值范围： false | true
					</code>
				</li>
				<li>
					<p>完整的例子</p>
					<code class="pre">stage {
	tcpsBackend "php-fpm" {
		.balancer = "roundRobin"
		.nodes = (
			["address": "127.0.0.1:9000"],
			["address": "127.0.0.1:9001"],
		)
	}

	app "main" {
		.webRoot = %baseDir + "/apps/diogin/root"

		fcgiProxy "php-fpm" {
			.toBackend = "php-fpm"
			.sendTimeout = 60s
			.recvTimeout = 60s
			.scriptFilename = ""
			.indexFile = "index.php"
			.keepConn = true
			.preferUnderscore = true
		}

		rule $path ~= "\.php$" {
			.handlets = ("php-fpm")
		}
	}
}
</code>
				</li>
			</ul>
		</li>
		<li id="stage-app-http1Proxy">
			<h4>stage &gt; app &gt; http1Proxy </h4>
			<p>http1Proxy 用于 http1.x 协议的后端代理。</p>
			<code class="pre">语法：http1Proxy [name] { ... }

http1Proxy {
	.proxyMode = "reverse"
	.toBackend = "proxy_name"
	.viaName = "gorox"
	.bufferClientContent = true
	.bufferServerContent = true
	.delRequestHeaders = ("sec-ch-ua-platform", "sec-ch-ua")
	.addRequestHeaders = (
		["x-root-id" : "xxx-xxx-xxx-xxx"],
		["X-Real-IP" : "$remote_addr"],
	)
}</code>
			<ul>
				<li>
					<p>.proxyMode 代理模式。</p>
					<code>语法：.proxyMode = ""
						默认值： ""
						取值范围： forward | reverse
					</code>
				</li>
				<li>
					<p>.toBackend 配置代理的名称</p>
					<code>语法：  .toBackend = "proxy_name"
						默认值：- ; 必填项
					</code>
				</li>
				<li>
					<p>.withCacher 选择使用 cache 的名字。</p>
					<code>语法： .withCacher = "cacher-name"
						默认值： -  
						取值范围：-
					</code>
				</li>
				<li>
					<p>.hostname 如果配置了，向后端转发时，就采用这个 hostname。</p>
					<code>语法： .hostname = ""
						默认值： ""
						取值范围：-
					</code>
				</li>
				<li>
					<p>.colonPort 如果配置了，向后端转发时，就采用这个 hostname。</p>
					<code>语法： .colonPort = ":8080" 
						默认值： ""
						取值范围：-
					</code>
				</li>
				<li>
					<p> .viaName 配置代理的名称 </p>
					<code>语法： .viaName = ""
							默认值： -  
							取值范围：-
					</code>
				</li>
				<li>
					<p>.bufferClientContent 是否开启客户端缓冲区？</p>
					<code>语法：.bufferClientContent = true
						默认值： true
						取值范围：false | true
					</code>
				</li>
				<li>
					<p>.bufferServerContent 是否开启服务端缓冲区？</p>
					<code>语法：.bufferServerContent = true
						默认值： true
						取值范围：false | true
					</code>
				</li>
				<li>
					<p> .delRequestHeaders 向后转发请求时候需要去除的 header 信息。</p>
					<code>语法：.delRequestHeaders = ("header1", "header2")
						默认值： nil
						取值范围：-
					</code>
				</li>
				<li>
					<p> .addRequestHeaders 向后转发请求时候需要添加的 header 信息。</p>
					<code class="pre">语法：.addRequestHeaders = (
	   ("viaName", "goprox"),
	   ("X-Real-IP", "xxxx"),
   )
默认值： nil
取值范围：-
</code>
				</li>
			</ul>
		</li>

		<li id="stage-app-http2Proxy">
			<h4>stage &gt; app &gt; http2Proxy </h4>
		</li>

		<li id="stage-app-http3Proxy">
			<h4>stage &gt; app &gt; http3Proxy </h4>
		</li>

		<li id="stage-app-sitex">
			<h4>stage &gt; app &gt; sitex </h4>
		</li>

		<li id="stage-app-static">
			<h4>stage &gt; app &gt; static </h4>
			<p>static 处理静态资源，例如（js、css、html）等。</p>
			<code class="pre">static {
	.webRoot = %baseDir + "/apps/app1/root"
	.indexFile = "index.html"
	.autoIndex = true
	.mimeTypes = [
		"jpg": "image/jpeg",
		"jpeg": "image/jpeg",
	]
	.defaultType = "application/octet-stream"
}
</code>
			<ul>
				<li>
					<p>.webRoot 设置请求的根目录，会把 .webRoot 的值和 URL 中的 path 结合起来读取文件。</p>
					<code>语法： .webRoot = "path" 
						默认值：-; 不能为空
						取值范围：-
					</code>
				</li>
				<li>
					<p>.aliasTo //TODO:</p>
					<code>.aliasTo = "path" 不能为空</code>
				</li>
				<li>
					<p>.indexFile 定义索引文件的名称，如果请求以斜杠结尾，gorox 会将其视为对目录的请求，并尝试在该目录中查找索引文件。</p>
					<code>语法： .indexFile = "index.html"
						默认值：index.html
						取值范围：-
					</code>
				</li>
				<li>
					<p>.autoIndex 对访问文件夹是否开启目录索引？</p>
					<code>语法 .autoIndex = false
						默认值：false
						取值范围：false | true
					</code>
				</li>
				<li>
					<p>.mimeTypes</p>
					<code class="pre">语法 .mimeTypes = ["html": "text/html", "jpg": "image/jpeg",]
默认值：[
	"7z": "application/x-7z-compressed",
	"atom": "application/atom+xml",
	"bin": "application/octet-stream",
	"bmp": "image/x-ms-bmp",
	"css": "text/css",
	"deb": "application/octet-stream",
	"dll": "application/octet-stream",
	"doc": "application/msword",
	"dmg": "application/octet-stream",
	"exe": "application/octet-stream",
	"flv": "video/x-flv",
	"gif": "image/gif",
	"htm": "text/html",
	"html": "text/html",
	"ico": "image/x-icon",
	"img": "application/octet-stream",
	"iso": "application/octet-stream",
	"jar": "application/java-archive",
	"jpg": "image/jpeg",
	"jpeg": "image/jpeg",
	"js": "application/javascript",
	"json": "application/json",
	"m4a": "audio/x-m4a",
	"mov": "video/quicktime",
	"mp3": "audio/mpeg",
	"mp4": "video/mp4",
	"mpeg": "video/mpeg",
	"mpg": "video/mpeg",
	"pdf": "application/pdf",
	"png": "image/png",
	"ppt": "application/vnd.ms-powerpoint",
	"ps": "application/postscript",
	"rar": "application/x-rar-compressed",
	"rss": "application/rss+xml",
	"rtf": "application/rtf",
	"svg": "image/svg+xml",
	"txt": "text/plain",
	"war": "application/java-archive",
	"webm": "video/webm",
	"webp": "image/webp",
	"xls": "application/vnd.ms-excel",
	"xml": "text/xml",
	"zip": "application/zip",
]
取值范围：-</code>
				</li>
				<li>
					<p>.defaultType 设置默认的 Content-type。</p>
					<code>语法： .defaultType = "application/octet-stream" 
						默认值： application/octet-stream; 不能为空
						取值范围：从 mimeTypes选择
					</code>
				</li>
			</ul>
		<li id="stage-app-webdavHandlet">
			<h4>stage &gt; app &gt; webdavHandlet </h4>
		</li>
		<li id="stage-app-gzipReviser">
			<h4>stage &gt; app &gt; gzipReviser </h4>
			<p>gzipReviser gzip压缩相关的配置</p>
			<code>gzipReviser {
					.compressLevel = 1
					.minLength = 8k // 开启压缩的最小长度
					.onContentTypes = ("text/html") // 压缩的类型
				}
			</code>
			<ul>
				<li>
					<p>.compressLevel 压缩级别，其中1代表压缩速度最快，9代表压缩比最高。</p>
					<code>语法： .compressLevel = 1
						默认值： 1
						取值范围：[1-9]
					</code>
				</li>
				<li>
					<p>.minLength 多小一下的数据不进行压缩。</p>
					<code>语法： .minLength = 8K
						默认值： -
						取值范围：(0, maxInt64]
					</code>
				</li>
				<li>
					<p>.onContentTypes 开启压缩的类型。</p>
					<code>语法： .onContentTypes = ("text/html", "text/css")
						默认值： ("text/html")
						取值范围：从 mimeTypes选择
					</code>
				</li>
			</ul>
		</li>
		<li id="stage-app-headReviser">
			<h4>stage &gt; app &gt; headReviser </h4>
			<p>headReviser 对 header 做添加和删除。</p>
			<ul>
				<li>
					<p>.addResponse 添加响应头信息。</p>
					<code class="pre">语法：.addResponse = [
	"cache-control" : "max-age=86400",
	"date": "Mon, 14 Sep 2015 03:19:14 GMT",
]
默认值：-
</code>
				</li>

				<li>
					<p>.addRequest 添加请求头信息用于转发请求。</p>
					<code class="pre">语法：.addRequest = [
	"env" : "gray",
	"x-root-id": "xxx-xxx-xxx-xxx",
]
默认值：-
</code>
				</li>

				<li>
					<p>.delRequest 删除请求头信息，一般用于转发请求。</p>
					<code> 语法：.delRequest = ("cookie", "date")
						默认值：-
					</code>
				</li>

				<li>
					<p>.delResponse 删除响应头信息</p>
					<code> 语法：.delResponse = ("cookie", "date")
						默认值：-
					</code>
				</li>

				<li>
					<p>例子</p>
					<code class="pre">app "test" {
	.hostnames = ("gorox.net")
	rule  {
		static { }
		headReviser {
			.addResponse = ["cache-control" : "max-age=86400"]
			.addRequest = ["env" : "gray"]
			.delRequest = ("cookie", "date")
			.delResponse = ("cookie", "date")
		}
		gzipReviser {
			.onContentTypes = ("text/css", "application/javascript")
		}
	}
}
</code>
				</li>
			</ul>
		</li>
		<li id="stage-app-replaceReviser">
			<h4>stage &gt; app &gt; replaceReviser </h4>
		</li>

		<li id="stage-app-ssiReviser">
			<h4>stage &gt; app &gt; ssiReviser </h4>
		</li>

		<li id="stage-app-wrapReviser">
			<h4>stage &gt; app &gt; wrapReviser </h4>
		</li>

		<li id="stage-app-sock1Proxy">
			<h4>stage &gt; app &gt; sock1Proxy </h4>
		</li>

		<li id="stage-app-sock2Proxy">
			<h4>stage &gt; app &gt; sock2Proxy </h4>
		</li>

		<li id="stage-app-sock3Proxy">
			<h4>stage &gt; app &gt; sock3Proxy </h4>
		</li>

		<li id="stage-svc">
			<h4>stage &gt; svc </h4>
		</li>

		<li id="stage-httpxServer">
			<h4>stage &gt; httpxServer </h4>
			<p>httpxServer goroxy 中对 http1.1 和 http2 服务端配置。</p>
			<p>例子</p>
			<code class="pre">stage {
	app "example_com" {
		.hostnames = ("example.com" "*.example.com")
		.webRoot = %baseDir + "/apps/example_com/root"
		.tlsCertificate = "/etc/tls/example_com.pem"
		.tlsPrivateKey = "/etc/tls/example_com.key"
	}

	httpxServer {
		.address = ":8080" // required
		.tlsMode = false
		.readTimeout = 60s
		.writeTimeout = 60s
		// .numGates = runtime.NumCPU() ; 不可配置，设置为cpu的核心数。
		.maxConnsPerGate = 100000
		.forApps = ("example_com")
		.enableTCPTun = false
		.enableUDPTun = false
		.maxContentSize = 1T
		.recvTimeout = 120s
		.sendTimeout = 120s
		.forceScheme = ""
		.adjustScheme = true
		.enableHTTP2 = false
		.h2cMode = false
	}
}
</code>
			<ul>
				<li>
					<p>.address 服务要监听的 IP:PORT，省略 IP 代表监听所有网卡的 IP。</p>
					<code>语法：.address = "127.0.0.1:8080"
						默认值：-; 必填项 
					</code>
				</li>
				<p>.tlsMode 是否开启 tls 协议（支持 https）</p>
				<code>语法：.tlsMode = bool
					默认值：false
					取值范围： false | true
				</code>
				<li>
					<p>.readTimeout 本次读数据超时时间，超过时间则连接关闭。</p>
					<code>语法：.readTimeout = Durations
						默认值：60s
						取值范围： (0s, 10m]
					</code>
				</li>
				<li>
					<p>.writeTimeout 本次写数据超时时间，超过时间则连接关闭。</p>
					<code>语法：.writeTimeout = Durations
						默认值：60s
						取值范围： (0s, 10m]
					</code>
				</li>

				<li>
					<p>.numGates 同时监听连接的线程数据量，默认 CPU 的核心数，目前不可配置</p>
					<code>语法：.numGates = runtime.NumCPU()
						默认值：runtime.NumCPU() // 目前不可配置
						取值范围： (0s, 10m]
					</code>
				</li>
				<li>
					<p>.maxConnsPerGate 每个 Gate 允许的最大并发连接数。</p>
					<code>语法：.maxConnsPerGate = 100000
						默认值：100000
						取值范围： (0, MaxInt32]
					</code>
				</li>
				<li>
					<p>.forApps 当前 httpxServer 应用于那些 App。</p>
					<code>语法：.forApps = ("test" "test2")
						默认值：nil
					</code>
				</li>
				<li>
					<p>.enableTCPTun 是否开启 tcp tunnel？这样 http 代理就可以转发 https 请求了。</p>
					<code>语法 .enableTCPTun = false
						默认值：false
						取值范围：false | true
					</code>
				</li>
				<li>
					<p>.enableUDPTun 是否开启 udp tunnel？</p>
					<code>语法 .enableUDPTun = false
						默认值：false
						取值范围：false | true
					</code>
				</li>
				<li>
					<p>.maxContentSize 数据包最大限制。</p>
					<code>语法：.maxContentSize = Sizes
						默认值：1T
						取值范围： (0s, 内存最大值)
					</code>
				</li>
				<li>
					<p>.recvTimeout 接收整个数据包的超时时间。</p>
					<code>语法：.recvTimeout = 120s
						默认值：120s
						取值范围： (0s, 10m]
					</code>
				</li>

				<li>
					<p>.sendTimeout 发送整个数据包的超时时间。</p>
					<code>语法：.sendTimeout = 120s
						默认值：120s
						取值范围： (0s, 10m]
					</code>
				</li>

				<li>
					<p>.adjustScheme 是否矫正协议？如果在 http 请求行里面使用了绝对 URL，并且绝对 URL 协议与当前的请求不一致。</p>
					<code>语法：.adjustScheme = false
						默认值：false
						取值范围：false | true
					</code>

					<p>例子</p>
					<code>// 如果在 https 请求中，使用了如下的请求行。如果.adjustScheme = true，则强制跳转到 http协议上。
						GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1
					</code>
				</li>

				<li>
					<p>.forceScheme 强制使用 http 或者 https 协议，如果请求和配置不一样则301跳转到指定协议上。</p>
					<code>语法：.forceScheme = "https"
						默认值：- 
						取值范围：http | https
					</code>
				</li>

				<li>
					<p>.enableHTTP2 是否开启 http2 协议。</p>
					<code>语法： .enableHTTP2 = false
						默认值：false
						取值范围：false | true
					</code>
				</li>

				<li>
					<p>.h2cMode 是否仅支持 http2 协议？</p>
					<code>语法：.h2cMode = false
						默认值：false
						取值范围：false | true
					</code>
				</li>
			</ul>

		</li>

		<li id="stage-http3Server">
			<h4>stage &gt; http3Server </h4>
		</li>

		<li id="stage-socksServer">
			<h4>stage &gt; socksServer </h4>
			<p></p>
			<code class="pre">stage {
	socksServer "socks" {
		.address = ":1080"
		.tlsMode = false
		.readTimeout = 60s
		.writeTimeout = 60s
		.numGates = NumCPU()
		.maxConnsPerGate = 1000
	}
}
</code>
			<ul>
				<li>
					<p>.address 服务要监听的 IP:PORT，省略 IP 代表监听所有网卡的 IP。</p>
					<code>语法：.address = "127.0.0.1:8080"
						默认值：-; 必填项 
					</code>
				</li>
				<li>
					<p>.tlsMode 是否开启 tls 协议（支持 https）</p>
					<code>语法：.tlsMode = bool
						默认值：false
						取值范围： false | true
					</code>
				</li>
				<li>
					<p>.readTimeout 本次读数据超时时间，超过时间则连接关闭。</p>
					<code>语法：.readTimeout = Durations
						默认值：60s
						取值范围： (0s, 10m]
					</code>
				</li>
				<li>
					<p>.writeTimeout 本次写数据超时时间，超过时间则连接关闭。</p>
					<code>语法：.writeTimeout = Durations
						默认值：60s
						取值范围： (0s, 10m]
					</code>
				</li>
				<li>
					<p>.maxConnsPerGate 每个 Gate 允许的最大并发连接数。</p>
					<code>语法：.maxConnsPerGate = 100000
						默认值：100000
						取值范围： (0, MaxInt32]
					</code>
				</li>
			</ul>
		</li>

		<li id="stage-cleanCronjob">
			<h4>stage &gt; cleanCronjob </h4>
		</li>

		<li id="stage-statCronjob">
			<h4>stage &gt; statCronjob </h4>
		</li>
	</ol>
</article>