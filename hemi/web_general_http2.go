// Copyright (c) 2020-2025 Zhang Jingcheng <diogin@gmail.com>.
// Copyright (c) 2022-2024 HexInfra Co., Ltd.
// All rights reserved.
// Use of this source code is governed by a BSD-style license that can be found in the LICENSE file.

// HTTP/2 types. See RFC 9113 and RFC 7541.

package hemi

import (
	"encoding/binary"
	"io"
	"net"
	"syscall"
	"time"
)

// http2Conn
type http2Conn interface {
	// Imports
	httpConn
	// Methods
}

// http2Conn_ is a parent.
type http2Conn_ struct { // for server2Conn and backend2Conn
	// Parent
	httpConn_
	// Conn states (stocks)
	// Conn states (controlled)
	outFrame http2OutFrame // used by c.manager() to send special out frames. immediately reset after use
	// Conn states (non-zeros)
	netConn      net.Conn            // *net.TCPConn, *tls.Conn, *net.UnixConn
	rawConn      syscall.RawConn     // for syscall. only usable when netConn is TCP/UDS
	peerSettings http2Settings       // settings of the remote peer
	inBuffer     *http2Buffer        // http2Buffer in use, for receiving incoming frames
	dynamicTable http2DynamicTable   // hpack dynamic table
	incomingChan chan any            // frames and errors generated by c.receiver() and waiting for c.manager() to consume
	inWindow     int32               // connection-level window size for incoming DATA frames
	outWindow    int32               // connection-level window size for outgoing DATA frames
	outgoingChan chan *http2OutFrame // frames generated by streams and waiting for c.manager() to send
	// Conn states (zeros)
	inFrame0      http2InFrame                           // incoming frame 0
	inFrame1      http2InFrame                           // incoming frame 1
	inFrame       *http2InFrame                          // current incoming frame. refers to inFrame0 or inFrame1 in turn
	activeStreams [http2MaxConcurrentStreams]http2Stream // active (open, remoteClosed, localClosed) streams
	vector        net.Buffers                            // used by writev in c.manager()
	fixedVector   [2][]byte                              // used by writev in c.manager()
	lastPingTime  time.Time                              // last ping time
	_http2Conn0                                          // all values in this struct must be zero by default!
}
type _http2Conn0 struct { // for fast reset, entirely
	activeStreamIDs    [http2MaxConcurrentStreams + 1]uint32 // ids of c.activeStreams. the extra 1 id is used for fast linear searching
	cumulativeInFrames int64                                 // num of incoming frames
	concurrentStreams  uint8                                 // num of active streams
	acknowledged       bool                                  // server settings acknowledged by client?
	pingSent           bool                                  // is there a ping frame sent and waiting for response?
	inBufferEdge       uint16                                // incoming data ends at c.inBuffer.buf[c.inBufferEdge]
	sectBack           uint16                                // incoming frame section (header or payload) begins from c.inBuffer.buf[c.sectBack]
	sectFore           uint16                                // incoming frame section (header or payload) ends at c.inBuffer.buf[c.sectFore]
	contBack           uint16                                // incoming continuation part (header or payload) begins from c.inBuffer.buf[c.contBack]
	contFore           uint16                                // incoming continuation part (header or payload) ends at c.inBuffer.buf[c.contFore]
}

func (c *http2Conn_) onGet(id int64, holder holder, netConn net.Conn, rawConn syscall.RawConn) {
	c.httpConn_.onGet(id, holder)

	c.netConn = netConn
	c.rawConn = rawConn
	c.peerSettings = http2InitialSettings
	if c.inBuffer == nil {
		c.inBuffer = getHTTP2Buffer()
		c.inBuffer.incRef()
	}
	c.dynamicTable.init()
	if c.incomingChan == nil {
		c.incomingChan = make(chan any)
	}
	c.inWindow = _2G1 - _64K1                      // as a receiver, we disable connection-level flow control
	c.outWindow = c.peerSettings.initialWindowSize // after we received the peer's preface, this value will be changed to the real value.
	if c.outgoingChan == nil {
		c.outgoingChan = make(chan *http2OutFrame)
	}
}
func (c *http2Conn_) onPut() {
	// c.inBuffer is reserved
	// c.table is reserved
	// c.incomingChan is reserved
	// c.outgoingChan is reserved
	c.inFrame0.zero()
	c.inFrame1.zero()
	c.inFrame = nil
	c.activeStreams = [http2MaxConcurrentStreams]http2Stream{}
	c.vector = nil
	c.fixedVector = [2][]byte{}
	c.lastPingTime = time.Time{}
	c._http2Conn0 = _http2Conn0{}
	c.netConn = nil
	c.rawConn = nil

	c.httpConn_.onPut()
}

func (c *http2Conn_) receiver() { // runner
	if DebugLevel() >= 1 {
		defer Printf("conn=%d c.receiver() quit\n", c.id)
	}
	for { // each incoming frame
		inFrame, err := c.recvInFrame()
		if err != nil {
			c.incomingChan <- err
			return
		}
		if inFrame.kind == http2FrameGoaway {
			c.incomingChan <- http2ErrorNoError
			return
		}
		c.incomingChan <- inFrame
	}
}

func (c *http2Conn_) recvInFrame() (*http2InFrame, error) {
	// Receive frame header
	c.sectBack = c.sectFore
	if err := c._growInFrame(9); err != nil {
		return nil, err
	}
	// Decode frame header
	if c.inFrame == nil || c.inFrame == &c.inFrame1 {
		c.inFrame = &c.inFrame0
	} else {
		c.inFrame = &c.inFrame1
	}
	inFrame := c.inFrame
	if err := inFrame.decodeHeader(c.inBuffer.buf[c.sectBack:c.sectFore]); err != nil {
		return nil, err
	}
	// Receive frame payload
	c.sectBack = c.sectFore
	if err := c._growInFrame(inFrame.length); err != nil {
		return nil, err
	}
	// Mark frame payload
	inFrame.inBuffer = c.inBuffer
	inFrame.efctFrom = c.sectBack
	inFrame.efctEdge = c.sectFore
	// Reject unexpected frames - pushPromise is NOT supported and continuation CANNOT be alone
	if inFrame.kind == http2FramePushPromise || inFrame.kind == http2FrameContinuation {
		return nil, http2ErrorProtocol
	}
	if !inFrame.isUnknown() {
		// Check the frame
		if err := http2InFrameCheckers[inFrame.kind](inFrame); err != nil {
			return nil, err
		}
	}
	c.cumulativeInFrames++
	if c.cumulativeInFrames == 20 && !c.acknowledged {
		return nil, http2ErrorSettingsTimeout
	}
	if inFrame.kind == http2FrameFields {
		if !inFrame.endFields { // continuations follow, join them into fields frame
			if err := c._appendContinuations(inFrame); err != nil {
				return nil, err
			}
		}
		// Got a new fields frame. Set deadline for next fields frame
		if err := c.setReadDeadline(); err != nil {
			return nil, err
		}
	}
	if DebugLevel() >= 2 {
		Printf("conn=%d <--- %+v\n", c.id, inFrame)
	}
	return inFrame, nil
}
func (c *http2Conn_) _growInFrame(size uint16) error {
	c.sectFore += size // size is limited, so won't overflow
	if c.sectFore <= c.inBufferEdge {
		return nil
	}
	// c.sectFore > c.inBufferEdge, needs grow.
	if c.sectFore > c.inBuffer.size() { // needs slide
		if c.inBuffer.getRef() == 1 { // no streams are referring to c.inBuffer, so just slide
			c.inBufferEdge = uint16(copy(c.inBuffer.buf[:], c.inBuffer.buf[c.sectBack:c.inBufferEdge]))
		} else { // there are still streams referring to c.inBuffer. use a new inBuffer
			oldBuffer := c.inBuffer
			c.inBuffer = getHTTP2Buffer()
			c.inBuffer.incRef()
			c.inBufferEdge = uint16(copy(c.inBuffer.buf[:], oldBuffer.buf[c.sectBack:c.inBufferEdge]))
			oldBuffer.decRef()
		}
		c.sectFore -= c.sectBack
		c.sectBack = 0
	}
	return c._fillInBuffer(c.sectFore - c.inBufferEdge)
}
func (c *http2Conn_) _appendContinuations(fieldsInFrame *http2InFrame) error { // into a single fields frame
	fieldsInFrame.inBuffer = nil // will be restored at the end of continuations
	var continuationInFrame http2InFrame
	c.contBack, c.contFore = c.sectFore, c.sectFore
	for { // each continuation frame
		// Receive continuation header
		if err := c._growContinuation(9, fieldsInFrame); err != nil {
			return err
		}
		// Decode continuation header
		if err := continuationInFrame.decodeHeader(c.inBuffer.buf[c.contBack:c.contFore]); err != nil {
			return err
		}
		// Check continuation header
		if continuationInFrame.length == 0 || fieldsInFrame.length+continuationInFrame.length > http2MaxFrameSize {
			return http2ErrorFrameSize
		}
		if continuationInFrame.streamID != fieldsInFrame.streamID || continuationInFrame.kind != http2FrameContinuation {
			return http2ErrorProtocol
		}
		// Receive continuation payload
		c.contBack = c.contFore
		if err := c._growContinuation(continuationInFrame.length, fieldsInFrame); err != nil {
			return err
		}
		// TODO: limit the number of continuation frames to avoid DoS attack
		c.cumulativeInFrames++ // got the continuation frame.
		// Append continuation frame to fields frame
		copy(c.inBuffer.buf[fieldsInFrame.efctEdge:], c.inBuffer.buf[c.contBack:c.contFore]) // may overwrite padding if exists
		fieldsInFrame.efctEdge += continuationInFrame.length
		fieldsInFrame.length += continuationInFrame.length // we don't care if padding is overwritten. just accumulate
		c.sectFore += continuationInFrame.length           // also accumulate fields payload, with padding included
		// End of fields frame?
		if continuationInFrame.endFields {
			fieldsInFrame.endFields = true
			fieldsInFrame.inBuffer = c.inBuffer // restore the inBuffer
			c.sectFore = c.contFore             // for next frame.
			return nil
		}
		c.contBack = c.contFore
	}
}
func (c *http2Conn_) _growContinuation(size uint16, fieldsInFrame *http2InFrame) error {
	c.contFore += size                // won't overflow
	if c.contFore <= c.inBufferEdge { // inBuffer is sufficient
		return nil
	}
	// Needs grow. Cases are (A is payload of the fields frame):
	// c.inBuffer: [| .. ] | A | 9 | B | 9 | C | 9 | D |
	// c.inBuffer: [| .. ] | AB | oooo | 9 | C | 9 | D |
	// c.inBuffer: [| .. ] | ABC | ooooooooooo | 9 | D |
	// c.inBuffer: [| .. ] | ABCD | oooooooooooooooooo |
	if c.contFore > c.inBuffer.size() { // needs slide
		if c.sectBack == 0 { // cannot slide again
			// This should only happens when looking for frame header, the 9 bytes
			return http2ErrorFrameSize
		}
		// Now slide. Skip holes (if any) when sliding
		inBuffer := c.inBuffer
		if c.inBuffer.getRef() != 1 { // there are still streams referring to c.inBuffer. use a new inBuffer
			c.inBuffer = getHTTP2Buffer()
			c.inBuffer.incRef()
		}
		c.sectFore = uint16(copy(c.inBuffer.buf[:], inBuffer.buf[c.sectBack:c.sectFore]))
		c.inBufferEdge = c.sectFore + uint16(copy(c.inBuffer.buf[c.sectFore:], inBuffer.buf[c.contBack:c.inBufferEdge]))
		if inBuffer != c.inBuffer {
			inBuffer.decRef()
		}
		fieldsInFrame.efctFrom -= c.sectBack
		fieldsInFrame.efctEdge -= c.sectBack
		c.sectBack = 0
		c.contBack = c.sectFore
		c.contFore = c.contBack + size
	}
	return c._fillInBuffer(c.contFore - c.inBufferEdge)
}
func (c *http2Conn_) _fillInBuffer(size uint16) error {
	n, err := c.readAtLeast(c.inBuffer.buf[c.inBufferEdge:], int(size))
	if DebugLevel() >= 2 {
		Printf("--------------------- conn=%d CALL READ=%d -----------------------\n", c.id, n)
	}
	if err != nil && DebugLevel() >= 2 {
		Printf("conn=%d error=%s\n", c.id, err.Error())
	}
	c.inBufferEdge += uint16(n)
	return err
}

func (c *http2Conn_) onPriorityInFrame(priorityInFrame *http2InFrame) error { return nil } // do nothing, priority frames are ignored
func (c *http2Conn_) onPingInFrame(pingInFrame *http2InFrame) error {
	if pingInFrame.ack { // pong
		if c.pingSent {
			return nil
		} else { // TODO: confirm this
			return http2ErrorProtocol
		}
	}
	if now := time.Now(); c.lastPingTime.IsZero() || now.Sub(c.lastPingTime) >= time.Second {
		c.lastPingTime = now
	} else {
		return http2ErrorEnhanceYourCalm
	}
	pongOutFrame := &c.outFrame
	pongOutFrame.stream = nil
	pongOutFrame.length = 8
	pongOutFrame.kind = http2FramePing
	pongOutFrame.ack = true
	pongOutFrame.payload = pingInFrame.effective()
	err := c.sendOutFrame(pongOutFrame)
	pongOutFrame.zero()
	return err
}
func (c *http2Conn_) onWindowUpdateInFrame(windowUpdateInFrame *http2InFrame) error {
	windowSize := binary.BigEndian.Uint32(windowUpdateInFrame.effective())
	if windowSize == 0 || windowSize > _2G1 {
		return http2ErrorProtocol
	}
	// TODO
	c.inWindow = int32(windowSize)
	Printf("conn=%d stream=%d windowUpdate=%d\n", c.id, windowUpdateInFrame.streamID, windowSize)
	return nil
}

func (c *http2Conn_) sendOutFrame(outFrame *http2OutFrame) error {
	outHeader := outFrame.encodeHeader()
	if len(outFrame.payload) > 0 {
		c.vector = c.fixedVector[0:2]
		c.vector[1] = outFrame.payload
	} else {
		c.vector = c.fixedVector[0:1]
	}
	c.vector[0] = outHeader
	n, err := c.writev(&c.vector)
	if DebugLevel() >= 2 {
		Printf("--------------------- conn=%d CALL WRITE=%d -----------------------\n", c.id, n)
		Printf("conn=%d ---> %+v\n", c.id, outFrame)
	}
	return err
}

func (c *http2Conn_) _decodeFields(fields []byte, join func(p []byte) bool) bool { // TODO: method value escapes to heap?
	var (
		I  uint32
		j  int
		ok bool
		N  []byte // field name
		V  []byte // field value
	)
	i, l := 0, len(fields)
	for i < l { // TODO
		b := fields[i]
		if b >= 1<<7 { // Indexed Header Field Representation
			I, j, ok = http2DecodeInteger(fields[i:], 7, 128)
			if !ok {
				Println("decode error")
				return false
			}
			i += j
			if I == 0 {
				Println("index == 0")
				return false
			}
			field := http2StaticTable[I]
			Printf("name=%s value=%s\n", field.nameAt(http2BytesStatic), field.valueAt(http2BytesStatic))
		} else if b >= 1<<6 { // Literal Header Field with Incremental Indexing
			I, j, ok = http2DecodeInteger(fields[i:], 6, 128)
			if !ok {
				Println("decode error")
				return false
			}
			i += j
			if I != 0 { // Literal Header Field with Incremental Indexing — Indexed Name
				field := http2StaticTable[I]
				N = field.nameAt(http2BytesStatic)
			} else { // Literal Header Field with Incremental Indexing — New Name
				N, j, ok = http2DecodeString(fields[i:])
				if !ok {
					Println("decode error")
					return false
				}
				i += j
				if len(N) == 0 {
					Println("empty name")
					return false
				}
			}
			V, j, ok = http2DecodeString(fields[i:])
			if !ok {
				Println("decode error")
				return false
			}
			i += j
			Printf("name=%s value=%s\n", N, V)
		} else if b >= 1<<5 { // Dynamic Table Size Update
			I, j, ok = http2DecodeInteger(fields[i:], 5, http2MaxTableSize)
			if !ok {
				Println("decode error")
				return false
			}
			i += j
			Printf("update size=%d\n", I)
		} else if b >= 1<<4 { // Literal Header Field Never Indexed
			I, j, ok = http2DecodeInteger(fields[i:], 4, 128)
			if !ok {
				Println("decode error")
				return false
			}
			i += j
			if I != 0 { // Literal Header Field Never Indexed — Indexed Name
				field := http2StaticTable[I]
				N = field.nameAt(http2BytesStatic)
			} else { // Literal Header Field Never Indexed — New Name
				N, j, ok = http2DecodeString(fields[i:])
				if !ok {
					Println("decode error")
					return false
				}
				i += j
				if len(N) == 0 {
					Println("empty name")
					return false
				}
			}
			V, j, ok = http2DecodeString(fields[i:])
			if !ok {
				Println("decode error")
				return false
			}
			i += j
			Printf("name=%s value=%s\n", N, V)
		} else { // Literal Header Field without Indexing
			Println("2222222222222")
			return false
		}
	}
	return true
}

/*
func (c *http2Conn_) _decodeString(src []byte, req *server2Request) (int, bool) {
	I, j, ok := http2DecodeInteger(src, 7, _16K)
	if !ok {
		return 0, false
	}
	H := src[0]&0x80 == 0x80
	src = src[j:]
	if I > uint32(len(src)) {
		return j, false
	}
	src = src[0:I]
	j += int(I)
	if H {
		// TODO
		return j, true
	} else {
		return j, true
	}
}
*/

func (c *http2Conn_) findStream(streamID uint32) http2Stream {
	if index := c._findStreamID(streamID); index != http2MaxConcurrentStreams { // found
		if DebugLevel() >= 2 {
			Printf("conn=%d findStream=%d at %d\n", c.id, streamID, index)
		}
		return c.activeStreams[index]
	} else { // not found
		return nil
	}
}
func (c *http2Conn_) joinStream(stream http2Stream) {
	if index := c._findStreamID(0); index != http2MaxConcurrentStreams { // found
		if DebugLevel() >= 2 {
			Printf("conn=%d joinStream=%d at %d\n", c.id, stream.nativeID(), index)
		}
		stream.setIndex(index)
		c.activeStreams[index] = stream
		c.activeStreamIDs[index] = stream.nativeID()
	} else { // this MUST not happen
		BugExitln("joinStream cannot find an empty slot")
	}
}
func (c *http2Conn_) _findStreamID(streamID uint32) uint8 {
	c.activeStreamIDs[http2MaxConcurrentStreams] = streamID // the stream id to search for
	index := uint8(0)
	for c.activeStreamIDs[index] != streamID {
		index++
	}
	return index
}
func (c *http2Conn_) quitStream(stream http2Stream) {
	index := stream.getIndex()
	if DebugLevel() >= 2 {
		Printf("conn=%d quitStream=%d at %d\n", c.id, stream.nativeID(), index)
	}
	c.activeStreams[index] = nil
	c.activeStreamIDs[index] = 0
}

func (c *http2Conn_) remoteAddr() net.Addr { return c.netConn.RemoteAddr() }

func (c *http2Conn_) setReadDeadline() error {
	if deadline := time.Now().Add(c.readTimeout); deadline.Sub(c.lastRead) >= time.Second {
		if err := c.netConn.SetReadDeadline(deadline); err != nil {
			return err
		}
		c.lastRead = deadline
	}
	return nil
}
func (c *http2Conn_) setWriteDeadline() error {
	if deadline := time.Now().Add(c.writeTimeout); deadline.Sub(c.lastWrite) >= time.Second {
		if err := c.netConn.SetWriteDeadline(deadline); err != nil {
			return err
		}
		c.lastWrite = deadline
	}
	return nil
}

func (c *http2Conn_) readAtLeast(dst []byte, min int) (int, error) {
	return io.ReadAtLeast(c.netConn, dst, min)
}
func (c *http2Conn_) write(src []byte) (int, error) { return c.netConn.Write(src) }
func (c *http2Conn_) writev(srcVec *net.Buffers) (int64, error) {
	return srcVec.WriteTo(c.netConn)
}

// http2Stream
type http2Stream interface {
	// Imports
	httpStream
	// Methods
	nativeID() uint32     // http/2 native stream id
	getIndex() uint8      // at activeStreams
	setIndex(index uint8) // at activeStreams
}

// http2Stream_ is a parent.
type http2Stream_[C http2Conn] struct { // for server2Stream and backend2Stream
	// Parent
	httpStream_[C]
	// Stream states (stocks)
	// Stream states (controlled)
	// Stream states (non-zeros)
	id uint32 // the stream id. we use 4 byte instead of int64 to save memory space! see activeStreamIDs
	// Stream states (zeros)
	_http2Stream0 // all values in this struct must be zero by default!
}
type _http2Stream0 struct { // for fast reset, entirely
	index uint8 // the index at s.conn.activeStreams
	state uint8 // http2StateOpen, http2StateLocalClosed, http2StateRemoteClosed
}

func (s *http2Stream_[C]) onUse(id uint32, conn C) {
	s.httpStream_.onUse(conn)

	s.id = id
}
func (s *http2Stream_[C]) onEnd() {
	s._http2Stream0 = _http2Stream0{}

	s.httpStream_.onEnd()
}

func (s *http2Stream_[C]) nativeID() uint32     { return s.id }
func (s *http2Stream_[C]) getIndex() uint8      { return s.index }
func (s *http2Stream_[C]) setIndex(index uint8) { s.index = index }

func (s *http2Stream_[C]) ID() int64 { return int64(s.id) } // implements httpStream interface

func (s *http2Stream_[C]) markBroken()    { s.conn.markBroken() }      // TODO: limit the breakage in the stream?
func (s *http2Stream_[C]) isBroken() bool { return s.conn.isBroken() } // TODO: limit the breakage in the stream?

func (s *http2Stream_[C]) setReadDeadline() error { // for content i/o only
	// TODO
	return nil
}
func (s *http2Stream_[C]) setWriteDeadline() error { // for content i/o only
	// TODO
	return nil
}

func (s *http2Stream_[C]) read(dst []byte) (int, error) { // for content i/o only
	// TODO
	return 0, nil
}
func (s *http2Stream_[C]) readFull(dst []byte) (int, error) { // for content i/o only
	// TODO
	return 0, nil
}
func (s *http2Stream_[C]) write(src []byte) (int, error) { // for content i/o only
	// TODO
	return 0, nil
}
func (s *http2Stream_[C]) writev(srcVec *net.Buffers) (int64, error) { // for content i/o only
	// TODO
	return 0, nil
}

// _http2In_ is a mixin.
type _http2In_ struct { // for server2Request and backend2Response
	// Parent
	*_httpIn_
	// Stream states (stocks)
	// Stream states (controlled)
	// Stream states (non-zeros)
	// Stream states (zeros)
}

func (r *_http2In_) onUse(parent *_httpIn_) {
	r._httpIn_ = parent
}
func (r *_http2In_) onEnd() {
	r._httpIn_ = nil
}

func (r *_http2In_) _growHeaders(size int32) bool {
	edge := r.inputEdge + size      // size is ensured to not overflow
	if edge < int32(cap(r.input)) { // fast path
		return true
	}
	if edge > _16K { // exceeds the max header section limit
		return false
	}
	input := GetNK(int64(edge)) // 4K/16K
	copy(input, r.input[0:r.inputEdge])
	if cap(r.input) != cap(r.stockInput) {
		PutNK(r.input)
	}
	r.input = input
	return true
}

func (r *_http2In_) readContent() (data []byte, err error) {
	// TODO
	return
}

// http2InFrame is the HTTP/2 incoming frame.
type http2InFrame struct { // 24 bytes
	inBuffer  *http2Buffer // the inBuffer that holds payload
	streamID  uint32       // the real type is uint31
	length    uint16       // length of payload. the real type is uint24, but we never allow sizes out of range of uint16, so use uint16
	kind      uint8        // see http2FrameXXX
	endFields bool         // is END_FIELDS flag set?
	endStream bool         // is END_STREAM flag set?
	ack       bool         // is ACK flag set?
	padded    bool         // is PADDED flag set?
	priority  bool         // is PRIORITY flag set?
	efctFrom  uint16       // (effective) payload from
	efctEdge  uint16       // (effective) payload edge
}

func (f *http2InFrame) zero() { *f = http2InFrame{} }

func (f *http2InFrame) decodeHeader(inHeader []byte) error {
	inHeader[5] &= 0x7f // ignore the reserved bit
	f.streamID = binary.BigEndian.Uint32(inHeader[5:9])
	if f.streamID != 0 && f.streamID&1 == 0 { // we don't support server push, so only odd stream ids are allowed
		return http2ErrorProtocol
	}
	length := uint32(inHeader[0])<<16 | uint32(inHeader[1])<<8 | uint32(inHeader[2])
	if length > http2MaxFrameSize {
		// An endpoint MUST send an error code of FRAME_SIZE_ERROR if a frame exceeds the size defined in SETTINGS_MAX_FRAME_SIZE,
		// exceeds any limit defined for the frame type, or is too small to contain mandatory frame data.
		return http2ErrorFrameSize
	}
	f.length = uint16(length)
	f.kind = inHeader[3]
	flags := inHeader[4]
	f.endFields = flags&0x04 != 0 && (f.kind == http2FrameFields || f.kind == http2FrameContinuation)
	f.endStream = flags&0x01 != 0 && (f.kind == http2FrameData || f.kind == http2FrameFields)
	f.ack = flags&0x01 != 0 && (f.kind == http2FrameSettings || f.kind == http2FramePing)
	f.padded = flags&0x08 != 0 && (f.kind == http2FrameData || f.kind == http2FrameFields)
	f.priority = flags&0x20 != 0 && f.kind == http2FrameFields
	return nil
}

func (f *http2InFrame) isUnknown() bool   { return f.kind >= http2NumFrameKinds }
func (f *http2InFrame) effective() []byte { return f.inBuffer.buf[f.efctFrom:f.efctEdge] } // effective payload

var http2InFrameCheckers = [http2NumFrameKinds]func(*http2InFrame) error{
	(*http2InFrame).checkAsData,
	(*http2InFrame).checkAsFields,
	(*http2InFrame).checkAsPriority,
	(*http2InFrame).checkAsRSTStream,
	(*http2InFrame).checkAsSettings,
	nil, // pushPromise frames are rejected priorly
	(*http2InFrame).checkAsPing,
	(*http2InFrame).checkAsGoaway,
	(*http2InFrame).checkAsWindowUpdate,
	nil, // continuation frames are rejected priorly
}

func (f *http2InFrame) checkAsData() error {
	var minLength uint16 = 1 // Data (..)
	if f.padded {
		minLength += 1 // Pad Length (8)
	}
	if f.length < minLength {
		return http2ErrorFrameSize
	}
	if f.streamID == 0 {
		return http2ErrorProtocol
	}
	var padLength, othersLen uint16 = 0, 0
	if f.padded {
		padLength = uint16(f.inBuffer.buf[f.efctFrom])
		othersLen += 1
		f.efctFrom += 1
	}
	if padLength > 0 { // drop padding
		if othersLen+padLength >= f.length {
			return http2ErrorProtocol
		}
		f.efctEdge -= padLength
	}
	return nil
}
func (f *http2InFrame) checkAsFields() error {
	var minLength uint16 = 1 // Field Block Fragment
	if f.padded {
		minLength += 1 // Pad Length (8)
	}
	if f.priority {
		minLength += 5 // Exclusive (1) + Stream Dependency (31) + Weight (8)
	}
	if f.length < minLength {
		return http2ErrorFrameSize
	}
	if f.streamID == 0 {
		return http2ErrorProtocol
	}
	var padLength, othersLen uint16 = 0, 0
	if f.padded { // skip pad length byte
		padLength = uint16(f.inBuffer.buf[f.efctFrom])
		othersLen += 1
		f.efctFrom += 1
	}
	if f.priority { // skip stream dependency and weight
		othersLen += 5
		f.efctFrom += 5
	}
	if padLength > 0 { // drop padding
		if othersLen+padLength >= f.length {
			return http2ErrorProtocol
		}
		f.efctEdge -= padLength
	}
	return nil
}
func (f *http2InFrame) checkAsPriority() error {
	if f.length != 5 {
		return http2ErrorFrameSize
	}
	if f.streamID == 0 {
		return http2ErrorProtocol
	}
	return nil
}
func (f *http2InFrame) checkAsRSTStream() error {
	if f.length != 4 {
		return http2ErrorFrameSize
	}
	if f.streamID == 0 {
		return http2ErrorProtocol
	}
	return nil
}
func (f *http2InFrame) checkAsSettings() error {
	if f.length%6 != 0 || f.length > 48 { // we allow 8 defined settings.
		return http2ErrorFrameSize
	}
	if f.streamID != 0 {
		return http2ErrorProtocol
	}
	if f.ack && f.length != 0 {
		return http2ErrorFrameSize
	}
	return nil
}
func (f *http2InFrame) checkAsPing() error {
	if f.length != 8 {
		return http2ErrorFrameSize
	}
	if f.streamID != 0 {
		return http2ErrorProtocol
	}
	return nil
}
func (f *http2InFrame) checkAsGoaway() error {
	if f.length < 8 {
		return http2ErrorFrameSize
	}
	if f.streamID != 0 {
		return http2ErrorProtocol
	}
	return nil
}
func (f *http2InFrame) checkAsWindowUpdate() error {
	if f.length != 4 {
		return http2ErrorFrameSize
	}
	return nil
}

// _http2Out_ is a mixin.
type _http2Out_ struct { // for server2Response and backend2Request
	// Parent
	*_httpOut_
	// Stream states (stocks)
	// Stream states (controlled)
	// Stream states (non-zeros)
	// Stream states (zeros)
}

func (r *_http2Out_) onUse(parent *_httpOut_) {
	r._httpOut_ = parent
}
func (r *_http2Out_) onEnd() {
	r._httpOut_ = nil
}

func (r *_http2Out_) addHeader(name []byte, value []byte) bool {
	// TODO
	return false
}
func (r *_http2Out_) header(name []byte) (value []byte, ok bool) {
	// TODO
	return
}
func (r *_http2Out_) hasHeader(name []byte) bool {
	// TODO
	return false
}
func (r *_http2Out_) delHeader(name []byte) (deleted bool) {
	// TODO
	return false
}
func (r *_http2Out_) delHeaderAt(i uint8) {
	// TODO
}

func (r *_http2Out_) sendChain() error {
	// TODO
	return nil
}
func (r *_http2Out_) _sendEntireChain() error {
	// TODO
	return nil
}
func (r *_http2Out_) _sendSingleRange() error {
	// TODO
	return nil
}
func (r *_http2Out_) _sendMultiRanges() error {
	// TODO
	return nil
}

func (r *_http2Out_) echoChain() error {
	// TODO
	return nil
}

func (r *_http2Out_) addTrailer(name []byte, value []byte) bool {
	// TODO
	return false
}
func (r *_http2Out_) trailer(name []byte) (value []byte, ok bool) {
	// TODO
	return
}
func (r *_http2Out_) trailers() []byte {
	// TODO
	return nil
}

func (r *_http2Out_) proxyPassBytes(data []byte) error { return r.writeBytes(data) }

func (r *_http2Out_) finalizeVague2() error {
	// TODO
	if r.numTrailerFields == 1 { // no trailer section
	} else { // with trailer section
	}
	return nil
}

func (r *_http2Out_) writeHeaders() error { // used by echo and pass
	// TODO
	r.fieldsEdge = 0 // now that header fields are all sent, r.fields will be used by trailer fields (if any), so reset it.
	return nil
}
func (r *_http2Out_) writePiece(piece *Piece, vague bool) error {
	// TODO
	return nil
}
func (r *_http2Out_) _writeTextPiece(piece *Piece) error {
	// TODO
	return nil
}
func (r *_http2Out_) _writeFilePiece(piece *Piece) error {
	// TODO
	return nil
}
func (r *_http2Out_) writeVector() error {
	// TODO
	return nil
}
func (r *_http2Out_) writeBytes(data []byte) error {
	// TODO
	return nil
}

// http2OutFrame is the HTTP/2 outgoing frame.
type http2OutFrame struct { // 64 bytes
	stream    http2Stream // the http/2 stream to which the frame belongs
	length    uint16      // length of payload. the real type is uint24, but we never use sizes out of range of uint16, so use uint16
	kind      uint8       // see http2FrameXXX. WARNING: http2FramePushPromise and http2FrameContinuation are NOT allowed! we don't use them.
	endFields bool        // is END_FIELDS flag set?
	endStream bool        // is END_STREAM flag set?
	ack       bool        // is ACK flag set?
	padded    bool        // is PADDED flag set?
	header    [9]byte     // frame header is encoded here
	outBuffer [8]byte     // small payload of the frame is placed here temporarily
	payload   []byte      // refers to the payload
}

func (f *http2OutFrame) zero() { *f = http2OutFrame{} }

func (f *http2OutFrame) encodeHeader() (outHeader []byte) { // caller must ensure the frame is legal.
	if f.stream.nativeID() > 0x7fffffff {
		BugExitln("stream id too large")
	}
	if f.length > http2MaxFrameSize {
		BugExitln("frame length too large")
	}
	if f.kind == http2FramePushPromise || f.kind == http2FrameContinuation {
		BugExitln("push promise and continuation are not allowed as out frame")
	}
	outHeader = f.header[:]
	outHeader[0], outHeader[1], outHeader[2] = byte(f.length>>16), byte(f.length>>8), byte(f.length)
	outHeader[3] = f.kind
	flags := uint8(0x00)
	if f.endFields && f.kind == http2FrameFields { // we never use http2FrameContinuation
		flags |= 0x04
	}
	if f.endStream && (f.kind == http2FrameData || f.kind == http2FrameFields) {
		flags |= 0x01
	}
	if f.ack && (f.kind == http2FrameSettings || f.kind == http2FramePing) {
		flags |= 0x01
	}
	if f.padded && (f.kind == http2FrameData || f.kind == http2FrameFields) {
		flags |= 0x08
	}
	outHeader[4] = flags
	binary.BigEndian.PutUint32(outHeader[5:9], f.stream.nativeID())
	return
}

// _http2Socket_ is a mixin.
type _http2Socket_ struct { // for server2Socket and backend2Socket
	// Parent
	*_httpSocket_
	// Stream states (stocks)
	// Stream states (controlled)
	// Stream states (non-zeros)
	// Stream states (zeros)
}

func (s *_http2Socket_) onUse(parent *_httpSocket_) {
	s._httpSocket_ = parent
}
func (s *_http2Socket_) onEnd() {
	s._httpSocket_ = nil
}

func (s *_http2Socket_) todo2() {
	s.todo()
}
